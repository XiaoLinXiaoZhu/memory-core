## 介绍

旧的 `memory-core` 包感觉存在不少问题，我打算重新设计一个更加精简的版本。这个版本甚至不包括 深度的 search 功能，完全由提示词驱动。

## 旧的架构

### server-memory (mcp 官方实现的memory)

所有的数据都是一条json格式的内容，分为 实体 和 关系 两个类型。
提供基本的 增删查改 功能。

缺点：并没能够提供很有效的记忆功能

### memory-core （我的第一版实现）

使用 sqlite 存储数据，提供了更丰富的记忆功能，包括：
- 增删查改
- 搜索
- 标签
- 上下文提示
- 统计

但是仍然没有很好的效果。

## 旧的框架的缺陷

### 提示词开销
因为这是mcp服务器，所有的方法都需要通过提示词来告诉模型如何访问、如何提供数据，这导致了提示词开销很大。

仅仅是为了告诉ai如何使用这些工具，就需要消耗将近2k的token。

### MCP 工具调用
除了告诉模型如何使用工具外，还需要告诉模型什么时候使用这些工具，这进一步增加了提示词的复杂性和开销。

而且模型往往需要非常强化的提示才能够学会如何使用这些工具，这导致模型的灵活性和适应性降低。

### 非常大的维护成本
随着记忆的不断增加，会有很多内容在存储库里面。很多时候，模型需要处理大量的无关内容，这导致了模型的性能下降。

## 新的架构

新的架构使用类似于 Zettelkasten 记忆片段盒笔记法，将记忆内容分为多个独立的记忆片段，每个记忆片段只包含一个主题或概念。这样可以减少提示词的开销，同时提高模型的灵活性和适应性。


### Zettelkasten 记忆片段盒笔记法

> 整个 zk 系统包含三个核心概念：

**第一：知识结构的流动性**

-   自底向上的归纳总结法，让知识的结构（或者说脉络）自动呈现出来

-   大部分笔记系统是“**自顶向下**”的，你一开始就要设定好分类，在往下创作

-   这是反直觉的，违背人思考方式的，它要求你一开始就让清楚整个世界是怎样的。
-   人类认识世界的过程是自底向上的，先看到土，思考自然怎么回事，又看到水和火，再往上抽象，思考自然是怎么回事，同之前的观点做融合修正。
-   自顶向下的思考过程有个前提，你一开始就能大致认清楚世界怎么回事情，后期发现前面考虑的不对会很痛苦。
-   自顶向下做熟悉的事情很方便，但对于探索和创新类思考很笨拙，违背大脑认识新事物的过程。

-   而 zk 笔记系统是 “**自底向上**”的，你从一个个原子想法（Atomic Idea）开始构建，让他们相互连接，当你不断的在笔记系统中添加想法时，它**内在结构/脉络就会逐步自动呈现出来**。
-   你会看到一小群想法聚成一个类别，他们都有一个共同的中心，和周边大量相关的想法，那么**这个自然汇聚出来的中心就会变得很重要**。
-   随着时间推移，该系统将越来越有结构（structured），你不需要去纠结它的主干在哪里，或者你应该按照什么主干或者主题来组织你的知识。
-   就让信息本身慢慢的将自己的结构和主干自动呈现出来，这就是当前这个时间点最优的结构。

-   所谓的 “知识结构（或者说脉络）”是动态变化的：

-   你的 zk 系统是“**有生命**”的，会呼吸的，它的结构会随着你不段加入的想法**持续进化**。
-   新的聚类会自己自动浮现出来，表明这个概念很重要。
-   其他不重要的想法或者子类可以合并或者让他慢慢变得不重要。
-   结构或者说脉络会**随着内容不断变化**。
-   在任何一个时间点，你可以认为，当前呈现出来的脉络或者结构即是你的 “第二大脑”当前的最优结构。

-   知识结构是非常个性化的：

-   为想法添加互联的方式是非常个人的行为，每个人做的都不一样，今天的我和昨天的我可能做的也不一样。
-   你的记忆片段盒完美的反应了你当前思考的路径。
-   同时它又反过来帮助你更好的思考。

**第二：想法间的相互连接**

-   传统笔记系统的问题：

-   并不鼓励你笔记之间做内链。
-   让你很容易沉浸在某个特定的主题下而忽略了同其他概念的联系。
-   容易忽略他们背后更大的 “big picture”。

-   zk 系统的设计准则：

-   鼓励你通过不断的浏览，持续发现并建立各种之前你没想到的连接。
-   当你忽然发现之前看似无关的概念和事件之间似乎存在实际的连接时，你将会形成更具有洞察力的见解，同时帮助你归纳出更深刻的理论。

-   zk 系统并不是单纯的 “笔记集合”，而是笔记间的互联关系，这才是更有价值的地方。

**第三：让你的 zk 系统发挥出它的效果**

-   你的 zk 系统会强迫你不断的将脑袋里的想法纸面化：

-   你是否有这样的经历，觉得自己非常了解一件事情了，但当你想向朋友们解释时，往往话来到嘴边就是不知道怎么准确完整描述。
-   大脑的不稳定性：听到的东西留在浅层记忆，并不稳定，随着时间会快速消退漂移，用自己的话复述是一个固化和加深的过程。
-   你认为你完全理解这个事情的，但这其实仅仅只是你的感觉，大脑欺骗了你。
-   直到你真的可以向朋友流畅阐述或者写道纸上，否则你是无法真的确认你理解某个东西的。

-   费曼（不是记忆片段盒发明人卢曼）如何确定自己完全理解一件事情？

-   他在每次听讲座的时候，都会准备好纸和笔。
-   假装自己正在给一群中学生讲课，把他想要理解的东西阐述给同学们听。
-   用他自己的话，将主要内容向学生描述一遍。

-   重新连接一遍你的各种想法，搞清楚大脑正在发生的事情

-   这会让你的大脑按自然的方式检测到之前没考虑到的 “盲点”。
-   可以帮助你将之前很散乱的想法，凝结（Crystallize）成更加坚固的东西。
-   复述一件事情同样能够帮助你的大脑内的神经元建立更多联系并不断进化。
-   

### 具体实现

我们取消 任何的标签或者元数据，使用“记忆片段”化的信息来组织记忆。

#### 外链

我们通过 `[[ABC]]` 的方式来引用其他记忆片段。这些记忆片段可以是存在的也可以是不存在的。

外联内容可以被 “展开” 成为记忆片段的内容。展开后，内容会被插入到当前记忆片段中。形式为：
```md
![[ABC]]start

ABC 内容


![[ABC]]end
```

如果 ABC 中同样包含外联内容，那么它会随着要求展开的深度而展开。

#### 记忆片段内容

对于每个记忆片段，它的内容如下：
```md
文件名称（外部）

记忆片段内容
```

每个记忆片段都是独立的，内容可以是任意的文本。

#### 对 ai 提供方法

我们不提供任何 内容查询功能，这样能够彻底避免search带来的缺陷，取而代之，我们使用强迫ai自行维护记忆片段内容的完整性和准确性。

比如可以通过引导 ai 维护一个 [[hint]] 的记忆片段，让它能够在任何时候都能从中获取有用的相关文件提示。

##### 1. 获取文件内容
```ts
GetContent(文件名称,展开深度);
```

从名称为 `文件名称` 的记忆片段中获取内容，并根据 `展开深度` 决定展开的层级。

##### 2. 创建/编辑 文件内容
```ts
SetContent(文件名称,内容);
```

将 `文件名称` 的内容设置为 `内容`。如果 `文件名称` 不存在，则会创建一个新的记忆片段。

##### 3. 删除文件内容
```ts
DeleteContent(文件名称);
```

从系统中删除名称为 `文件名称` 的记忆片段。

##### 4. 重命名/合并文件内容
```ts
RenameContent(旧文件名称, 新文件名称);
```

将名称为 `旧文件名称` 的记忆片段重命名为 `新文件名称`。如果 `新文件名称` 已经存在，则会将其内容合并到 `旧文件名称` 中。

同时它会更新所有引用了 `旧文件名称` 的地方，将其改为 `新文件名称`。

##### 5. 获取提示
```ts
GetHints(文件数量);
```

每一个文件都会被分析权重，通过递归调用 GetWeight() 来实现。

```ts
// 当 A 拥有 往后的链接时
A.GetWeight() = (A_1.GetWeight() + A_2.GetWeight() + ... + A_n.GetWeight()) / n-1;

// 当 A 没有 往后的链接时
A.GetWeight() = 1;
```

之后，系统会根据每个文件的权重，提供由高到低的 `文件数量` 个 文件名称。

##### 6. 获取优化建议
```ts
GetSuggestions(优化参数，最大文件数量);
```

系统会根据每个文件的内容和权重为每个文件计算其价值
$$价值 = 权重 / 文件字符数$$

之后，按照价值排序，提供由低到高的 价值小于 `优化参数` 的 `最大文件数量` 个 文件名称。

##### 7. 将内容提取到新记忆片段
```ts
ExtractContent(源文件名称, 内容, 新文件名称);
```

#### 储存模式

将所有文件储存在指定的文件夹下，文件名使用 `文件名称.md` 的格式。